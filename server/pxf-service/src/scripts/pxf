#!/bin/bash
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

#
# pxf-service    start/stop/restart/initialize/reset/status the PXF instance
#

[[ -n "$DEBUG" ]] && set -x

WORKING_DIR="$(pwd)"

# Follow symlinks to find the real script
cd "$(dirname "$0")" || exit 1
script_file=$(pwd)/$(basename "$0")
while [[ -L "$script_file" ]]; do
  script_file=$(readlink "$script_file")
  cd "$(dirname "$script_file")" || exit 1
  script_file=$(pwd)/$(basename "$script_file")
done

parent_script_dir="$( (cd "$( dirname "${script_file}" )/.." && pwd -P) )"
cd "$WORKING_DIR" || exit 1

# establish PXF_HOME and global vars used by all commands
# do not allow overrides of PXF_HOME so that his script only manages this given installation
export PXF_HOME=$parent_script_dir
identity="pxf-service"
[[ -n "$APP_NAME" ]] && identity="$APP_NAME"

[[ -z "$STOP_WAIT_TIME" ]] && STOP_WAIT_TIME="60"

jarfile=$(find "${PXF_HOME}/server/" -name "pxf-service-*.jar" -type f)
set_env_script=${PXF_HOME}/bin/setenv.sh
default_env_script=${PXF_HOME}/conf/pxf-env-default.sh
server_templates=${PXF_HOME}/templates/server-templates/

SED_OPTS=(-i)
if [[ $OSTYPE == "darwin"* ]]; then
    SED_OPTS+=("")
fi
SED_OPTS+=(-e)

# ANSI Colors
echoRed() { echo $'\e[0;31m'"$1"$'\e[0m'; }
echoGreen() { echo $'\e[0;32m'"$1"$'\e[0m'; }
echoYellow() { echo $'\e[0;33m'"$1"$'\e[0m'; }

function validate_user()
{
    # shellcheck disable=SC2012
    [[ $(id -u) == "0" ]] && run_user=$(ls -ld "$jarfile" | awk '{print $3}')

    # Run as user specified in RUN_AS_USER
    if [[ -n "$RUN_AS_USER" ]]; then
        id -u "$RUN_AS_USER" || {
            echoRed "Cannot run as '$RUN_AS_USER': no such user"
            exit 2
        }
        [[ $(id -u) == 0 ]] || {
            echoRed "Cannot run as '$RUN_AS_USER': current user is not root"
            exit 4
        }
        run_user="$RUN_AS_USER"
    fi

    # make sure run_user is not root
    [[ -n ${run_user} && $(id -u "${run_user}") == "0" ]] && { fail "Cannot run as root user. This is considered insecure."; }
}

function confirm_with_user()
{
    echoGreen  '*****************************************************************************'
    echoGreen  '* The PXF_CONF variable is not defined, using default location'
    echoGreen  "* Using ${PXF_CONF} for user configurations"
    echoYellow '* WARNING: using this directory is not recommended for production deployments'
    echoGreen  '*****************************************************************************'

    read -rp 'Do you want to proceed? [Y]: ' answer
    answer=${answer:-'Y'}
    case ${answer:0:1} in
        y|Y)
            echoGreen 'Proceeding with the initialization'
        ;;
        *)
            echoYellow 'Initialization aborted'
            exit 1
        ;;
    esac
}

function update_pxf_conf()
{
    if [[ -z $PXF_CONF ]]; then
        # PXF_CONF was not specified during init command
        # need to default to user's home directory and ask for confirmation, unless silent mode is used
        local current_user pxf_user_home
        current_user=$( id -un )
        pxf_user_home=$HOME
        if [[ -z $pxf_user_home ]]; then
            fail "PXF_CONF is not set and user $current_user home directory is not defined"
        elif [[ ! -d ${pxf_user_home} ]]; then
            fail "PXF_CONF is not set and user $current_user home directory $pxf_user_home does not exist"
        else
            export PXF_CONF=${pxf_user_home}/pxf
            if [[ $silent == false ]]; then
                confirm_with_user
            fi
        fi
    fi

    echoYellow "Using $PXF_CONF as a location for user-configurable files"

    # update the value on PXF_CONF in the default env file
    sed "${SED_OPTS[@]}" "s|{PXF_CONF:-.*}$|{PXF_CONF:-\"${PXF_CONF}\"}|g" "$default_env_script"
}

function getEnvironment()
{
    local USER_SPECIFIED_JAVA_HOME=${JAVA_HOME}
    # load default environment
    if [[ ! -f $default_env_script ]]; then
        fail "Failed to find $default_env_script"
    fi
    # shellcheck source=/Users/pivotal/workspace/pxf/server/pxf-service/src/scripts/pxf-env-default.sh
    source "$default_env_script"
    # we may have just overridden the user's intended JAVA_HOME
    # by sourcing PXF_CONF/conf/pxf-env.sh
    [[ ${PRESERVE_JAVA_HOME} == true ]] && JAVA_HOME=${USER_SPECIFIED_JAVA_HOME}
    pid_file="$PXF_RUNDIR/${identity}.pid"
}

function checkJavaHome()
{
    # Find Java
    if [[ -n "$JAVA_HOME" ]] && [[ -x "$JAVA_HOME/bin/java" ]]; then
        javaexe="$JAVA_HOME/bin/java"
    elif type -p java > /dev/null 2>&1; then
        javaexe=$(type -p java)
    elif [[ -x "/usr/bin/java" ]];  then
        javaexe="/usr/bin/java"
    else
        fail "\$JAVA_HOME=$JAVA_HOME is invalid. Set \$JAVA_HOME in your environment before initializing PXF."
    fi
}

# print error message and return with error code
function fail()
{
    echoRed "ERROR: $1"
    exit 1
}

#
# configureTemplates configures based on pre-configured template files.
#
function configureTemplates()
{
    # copy configuration files into instance
    cp "$server_templates"/bin/{kill-pxf,setenv}.sh "${parent_script_dir}/bin"
    return 0
}

#
# waitForSpringBoot waits for spring boot to finish loading
# for given attempts number.
#
function waitForSpringBoot()
{
    attempts=0
    max_attempts=$1 # number of attempts to connect
    echo_after_attempts=$2 # only start echoing after this number of attempts
    sleep_time=1 # sleep 1 second between attempts

    # wait until spring boot is up:
    echoYellow 'Checking if PXF is up and running...'
    until $curl --silent --connect-timeout 1 -I "http://localhost:$PXF_PORT" | grep 'PXF Server' > /dev/null; do
        if (( ++attempts == max_attempts )); then
            echoRed 'ERROR: PXF is down - the application is not running'
            return 1
        fi
        if (( attempts >= echo_after_attempts )); then
            echoYellow "PXF not responding, re-trying after $sleep_time second (attempt number ${attempts})"
        fi
        sleep $sleep_time
    done

    return 0
}

#
# checkWebapp checks if PXF is up for $1 attempts and then
# verifies PXF webapp is functional
#
function checkWebapp()
{
    waitForSpringBoot "$1" "$2" || return 1

    curlResponse=$($curl -s "http://localhost:${PXF_PORT}/actuator/health")
    expectedResponse='{"status":"UP"}'

    [[ $curlResponse =~ $expectedResponse ]] && return 0;
    fail 'PXF is inaccessible. Check logs for more information'
}

# determines whether the application is running
function isRunning() {
    ps -p "$1" &> /dev/null
}

function checkPermissions() {
    touch "$pid_file" &> /dev/null || { echoRed "Operation not permitted (cannot access pid file)"; return 4; }
}

function createLogsDir()
{
    # logs dir is likely outside PXF_HOME, setup only if it does not yet exist
    if [[ ! -d $PXF_LOGDIR ]]; then
        echoGreen "Creating PXF logs directory $PXF_LOGDIR ..."
        mkdir -p "$PXF_LOGDIR"
        chmod 700 "$PXF_LOGDIR"
        if [[ -n "$run_user" ]]; then
            chown "$run_user" "$PXF_RUNDIR"
        fi
    fi
}

function createRunDir()
{
    echoGreen "Creating PXF runtime directory $PXF_RUNDIR ..."
    mkdir -p "$PXF_RUNDIR"
    chmod 700 "$PXF_RUNDIR"
    if [[ -n "$run_user" ]]; then
      chown "$run_user" "$PXF_RUNDIR"
    fi
}

function generateUserConfigs()
{
    # create and setup user configuration directories (only if they do not exist)
    setup_conf_directory "${PXF_CONF}"
    setup_conf_directory "${PXF_CONF}/conf" "${PXF_HOME}/templates/user/conf"
    setup_conf_directory "${PXF_CONF}/keytabs"
    setup_conf_directory "${PXF_CONF}/lib"
    setup_conf_directory "${PXF_CONF}/servers/default"
    setup_conf_directory "${PXF_CONF}/templates" "${PXF_HOME}/templates/user/templates" 'override'
}

function setup_conf_directory()
{
    local target=$1
    local source=$2
    local override=$3

    if [[ ! -d $target ]]; then
        if [[ -z $source ]]; then
            echoGreen "Creating configuration directory $target ..."
            mkdir -p "$target"
        else
            echoGreen "Copying configurations from $source to $target ..."
            cp -R "$source" "$(dirname "$target")"
        fi
        if [[ -n "$run_user" ]]; then
            chown -R "$run_user" "$target"
        fi
    elif [[ -n $source && -n $override ]]; then
        echoGreen "Updating configurations from $source to $target ..."
        cp -R "$source" "$(dirname "$target")"
        if [[ -n "$run_user" ]]; then
            chown -R "$run_user" "$target"
        fi
    else
        echoGreen "Directory $target already exists, no update required"
        return 0
    fi
}

function validate_system()
{
    # validate curl
    if ! curl=$(command -v curl); then
        fail 'curl is not installed, please install'
    fi
}

function printUsage()
{
    local normal bold
    normal=$(tput sgr0)
    bold=$(tput bold)
    cat <<-EOF
	${bold}NAME${normal}
	    pxf - manage a single PXF instance or a PXF cluster

	${bold}usage${normal}:  pxf <command> [-y]
	        pxf cluster <command>
	        pxf {-h | --help}
	EOF
}

# doHelp handles the help command
doHelp() {
    local normal bold
    normal=$(tput sgr0)
    bold=$(tput bold)
    printUsage
    cat <<-EOF

	${bold}List of commands${normal}:
	  init                initialize the local PXF server instance, install PXF extension under \$GPHOME
	  start               start the local PXF server instance
	  stop                stop the local PXF server instance
	  restart             restart the local PXF server instance (not supported for cluster)
	  status              show the status of the local PXF server instance
	  version             show the version of PXF server
	  reset               undo the local PXF initialization
	  register            install PXF extension under \$GPHOME (useful after upgrades of Greenplum server)
	  cluster <command>   perform <command> on all the segment hosts in the cluster; try ${bold}pxf cluster help$normal

	  sync <hostname>     synchronize \$PXF_CONF/{conf,lib,servers} directories onto <hostname>. Use --delete to delete extraneous remote files

	${bold}Options${normal}:
	  -h, --help    show command help
	  -y            answer yes, use default PXF_CONF=\$HOME/pxf user configuration directory
	EOF
    exit 0
}

function promptUser() {
    echoGreen "$1"
    read -r answer
    [[ $answer == y || $answer == Y ]]
}

# doReset handles the reset command
function doReset()
{
    local force=$2
    echoRed "This is a destructive action!"

    if [[ -f "$pid_file" ]]; then
        pid=$(cat "$pid_file")
        isRunning "$pid" && { echoYellow "PXF is running [$pid]"; }
    fi

    local prompt='Ensure your local PXF instance is stopped before continuing.
    Press [y] to continue:'
    if [[ $force != -f && $force != --force ]] && ! promptUser "$prompt"; then
        echoYellow 'pxf reset cancelled'
        return 1
    fi

    if doStatus > /dev/null; then
        fail "PXF is running. Stop PXF before running 'pxf [cluster] reset'"
    fi

    echoYellow "Ignoring ${PXF_CONF}..."
    echoYellow "Cleaning ${PXF_RUNDIR}..."
    rm -rf "$PXF_RUNDIR"
    echoYellow "Cleaning templates ${parent_script_dir}/bin/{kill-pxf,setenv}.sh"
    rm -f "${parent_script_dir}/bin/kill-pxf.sh"
    rm -f "${parent_script_dir}/bin/setenv.sh"

    echoYellow "Reverting changes to ${default_env_script}..."
    sed "${SED_OPTS[@]}" "s|{PXF_CONF:-\"${PXF_CONF}/*\"}|{PXF_CONF:-NOT_INITIALIZED}|g" "$default_env_script"

    echoGreen "Finished resetting PXF"
}

function installExternalTableExtension()
{
    if [[ -d ${parent_script_dir}/gpextable ]]; then
        if [[ -z "${GPHOME}" ]]; then
            echo 'WARNING: environment variable GPHOME is not set, skipping install of Greenplum External Table PXF Extension'
        elif [[ ! -f ${GPHOME}/greenplum_path.sh ]]; then
            echo "WARNING: environment variable GPHOME (${GPHOME}) must be set to a valid Greenplum installation, skipping install of Greenplum External Table PXF Extension'"
        else
            echo "Installing Greenplum External Table PXF Extension into ${GPHOME}"
            cp -av ${parent_script_dir}/gpextable/* ${GPHOME}
        fi
    fi
}

# doInit handles the init command
function doInit()
{
    if ! grep 'PXF_CONF:-NOT_INITIALIZED' "$default_env_script" > /dev/null; then
        echoYellow "PXF has already been initialized. Use 'pxf [cluster] reset' before attempting to re-initialize PXF"
        return 1
    fi

    update_pxf_conf
    # preserve JAVA_HOME in case user is trying to change it
    PRESERVE_JAVA_HOME=true getEnvironment
    checkJavaHome
    generateUserConfigs || return 1
    editPxfEnvSh || return 1
    configureTemplates || return 1
    createLogsDir || return 1
    createRunDir  || return 1
    installExternalTableExtension || return 1
}

function editPxfEnvSh()
{
    sed "${SED_OPTS[@]}" "s|.*JAVA_HOME=.*|JAVA_HOME=${JAVA_HOME}|g" "${PXF_CONF}/conf/pxf-env.sh"
}

#
# doStart handles start commands
# command is executed as the current user
#
# after start, uses checkWebapp to verify the PXF webapp was loaded
# successfully
#
function doStart()
{
    getEnvironment
    checkPxfConf
    checkJavaHome
    warnUserEnvScript
    do_start
}

function do_start() {
    if [[ -f "$pid_file" ]]; then
        pid=$(cat "$pid_file")
        isRunning "$pid" && { echoYellow "PXF is already running [$pid]"; return 0; }
    fi

    [[ -f $set_env_script ]] && source "$set_env_script"

    local arguments=(-Dsun.misc.URLClassPath.disableJarChecking=true "${JAVA_OPTS[@]}" -jar "$jarfile" $RUN_ARGS)
    [[ $PXF_DEBUG == true ]] && arguments+=(-Dagentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000)

    working_dir=$(dirname "$jarfile")
    pushd "$working_dir" > /dev/null || exit 1
    checkPermissions || return $?
    if [[ -n "$run_user" ]]; then
      su -s /bin/sh -c "$javaexe $(printf "\"%s\" " "${arguments[@]}") >> \"/dev/null\" 2>&1 & echo \$!" "$run_user" > "$pid_file"
      pid=$(cat "$pid_file")
    else
      "$javaexe" "${arguments[@]}" >> /dev/null 2>&1 &
      pid=$!
      disown $pid
      echo "$pid" > "$pid_file"
    fi
    [[ -z $pid ]] && fail "Failed to start PXF"
    checkWebapp 300 10 || return 1
    echoGreen "PXF started [$pid]. Listening on port $PXF_PORT";
}

#
# doStop handles stop commands
# command is executed as the current user
#
# the -force flag is passed to catalina.sh to enable force-stopping
# the JVM
#
function doStop()
{
    getEnvironment
    checkPxfConf
    checkJavaHome
    warnUserEnvScript

    working_dir=$(dirname "$jarfile")
    pushd "$working_dir" > /dev/null
    [[ -f $pid_file ]] || { echoYellow "Not running (pidfile not found). Is PXF running? Stop aborted."; return 0; }
    pid=$(cat "$pid_file")
    isRunning "$pid" || { echoYellow "Not running (process ${pid}). Removing stale pid file."; rm -f "$pid_file"; return 0; }

    echoYellow "Stopping PXF [$pid]..."

    # first try endpoint (assume it might be disabled)
    if $curl --max-time 5 --silent -X POST "localhost:$PXF_PORT/actuator/shutdown" | grep "Shutting down, bye..." > /dev/null; then
      for i in $(seq 1 $STOP_WAIT_TIME); do
        isRunning "$pid" || { echoGreen "PXF stopped [$pid]"; return 0; }
        sleep 1
      done
    fi

    # second try a nice kill and if that doesn't work force kill
    do_stop "$pid" "$pid_file" || do_stop "$pid" "$pid_file" "-f"
}

do_stop() {
  local killcmd=(kill)
  [[ $3 == -f ]] && killcmd+=(-9)
  killcmd+=("$1")
  "${killcmd[@]}" &> /dev/null || { echoRed "Unable to terminate process $1"; return 1; }
  for i in $(seq 1 $STOP_WAIT_TIME); do
    isRunning "$1" || { echoGreen "PXF stopped [$1]"; rm -f "$2"; return 0; }
    [[ $i -eq STOP_WAIT_TIME/2 ]] && "${killcmd[@]}" &> /dev/null
    sleep 1
  done
  echoRed "Unable to terminate process $1";
  return 1;
}

function doStatus()
{
    getEnvironment
    checkJavaHome
    checkPxfConf
    warnUserEnvScript
    checkWebapp 1 0 && { echoGreen "PXF is listening on port $PXF_PORT"; } || return 1
}

function doSync()
{
    local target_host=$1
    if [[ -z $target_host ]]; then
        fail 'A destination hostname must be provided'
    fi
    getEnvironment
    checkPxfConf
    warnUserEnvScript
    rsync -az${DELETE:+ --delete} -e "ssh -o StrictHostKeyChecking=no" "$PXF_CONF"/{conf,lib,servers} "${target_host}:$PXF_CONF"
}

function doCluster()
{
    local pxf_cluster_command=$2 is_init=false
    [[ ${pxf_cluster_command} == init ]] && is_init=true
    PRESERVE_JAVA_HOME=${is_init} getEnvironment
    # Go CLI handles unset PXF_CONF when appropriate
    [[ $PXF_CONF == NOT_INITIALIZED ]] && unset PXF_CONF
    [[ ${is_init} == false ]] && warnUserEnvScript
    "${parent_script_dir}/bin/pxf-cli" "$@"
}

function warnUserEnvScript()
{
   local user_env_script=${PXF_CONF}/conf/pxf-env.sh
   [[ -f $user_env_script ]] || echoYellow "WARNING: failed to find ${user_env_script}, default parameters will be used"
}

function checkPxfConf()
{
    if [[ $PXF_CONF == NOT_INITIALIZED ]] || grep 'PXF_CONF:-NOT_INITIALIZED' "$default_env_script" > /dev/null; then
        fail "PXF is not yet initialized, you must run the 'pxf [cluster] init' command first."
    fi
}

pxf_script_command=$1

silent=false

validate_user
validate_system

case $pxf_script_command in
    'init')
        if [[ $2 == -y || $2 == -Y ]]; then
            silent=true
        fi
        doInit
        ;;
    'register')
        installExternalTableExtension
	;;
    'start')
        doStart
        ;;
    'stop')
        doStop
        ;;
    'restart')
        doStop
        sleep 1s
        doStart
        ;;
    'status')
        doStatus
        ;;
    'sync')
        if [[ $2 == -d || $2 == --delete ]]; then
            DELETE=1 doSync "$3"
        else
            doSync "$2"
        fi
        ;;
    'help' | '-h' | '--help')
        doHelp
        ;;
    'version' | '--version' | '-v')
        "${parent_script_dir}/bin/pxf-cli" --version
        ;;
    'cluster')
        doCluster "$@"
        ;;
    'reset')
        doReset "$@"
        ;;
    *)
        printUsage
        exit 2
        ;;
esac

exit $?
