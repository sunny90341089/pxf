# TODO: spring_boot_todo decide which endpoints are exposed by default
management.endpoints.web.exposure.include=*
management.endpoints.enabled-by-default=true
management.endpoint.shutdown.enabled=true

server.port=${pxf.port:5888}
server.tomcat.threads.max=${pxf.max.threads:200}

server.error.include-message=always
server.error.include-stacktrace=on_param
server.error.include-exception=false

# 1. Lazy initialization may reduce the number of beans created when the
#    application is starting – therefore, we can improve the startup time of
#    the application
# 2. As none of the beans are created until they are needed, we could mask
#    issues, getting them in run time instead of startup time
# 3. The issues can include out of memory errors, misconfigurations, or
#    class-definition-found errors
# 4. Also, when we're in a web context, triggering bean creation on demand will
#    increase the latency of HTTP requests – the bean creation will affect only
#    the first request, but this may have a negative impact in load-balancing
#    and auto-scaling.
spring.main.lazy-initialization=true

# Settings migrated from web.xml
server.server-header=PXF Server
server.tomcat.accept-count=100
server.tomcat.connection-timeout=20000
server.max-http-header-size=${pxf.tomcat.max-header-size:1048576}
pxf.tomcat.max-header-count=30000

# timeout (ms) for the request - 1 day
spring.mvc.async.request-timeout=86400000

# legacy fragmenter cache, renamed to metadata cache
pxf.metadata-cache-enabled=${pxf.fragmenter.cache:true}

pxf.task.thread-name-prefix=pxf-task-
pxf.task.pool.allow-core-thread-timeout=false
pxf.task.pool.core-size=8
pxf.task.pool.max-size=${pxf.max.threads:200}
pxf.task.pool.queue-capacity=0
